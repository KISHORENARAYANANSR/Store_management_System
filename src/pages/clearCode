import React, { useEffect, useState } from "react";
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  BarChart,
  Bar,
} from "recharts";
import * as XLSX from "xlsx";
import "../styles/dashboard.css";
import { products } from "../data/products";
import { useNavigate } from "react-router-dom";

export default function ManagerDashboard() {
  const [orders, setOrders] = useState(() => {
    const saved = localStorage.getItem("orders");
    console.log("üîÑ Loading orders from localStorage:", saved ? JSON.parse(saved).length : 0);
    return saved ? JSON.parse(saved) : [];
  });
  
  const [filterVisible, setFilterVisible] = useState(false);
  
  const [filterDate, setFilterDate] = useState(() => {
    return localStorage.getItem("filterDate") || "";
  });
  
  const [filterStatus, setFilterStatus] = useState(() => {
    return localStorage.getItem("filterStatus") || "All";
  });

  const [filterCategory, setFilterCategory] = useState(() => {
    return localStorage.getItem("filterCategory") || "All";
  });
  
  const [popupOrder, setPopupOrder] = useState(null);
  const [deliveredQuantities, setDeliveredQuantities] = useState({});
  const [reorderVisible, setReorderVisible] = useState(false);
  
  const [reorderProducts, setReorderProducts] = useState(() => {
    const saved = localStorage.getItem("reorderProducts");
    return saved ? JSON.parse(saved) : [];
  });
  
  const [uploadVisible, setUploadVisible] = useState(false);
  
  const [costData, setCostData] = useState(() => {
    const saved = localStorage.getItem("costData");
    return saved ? JSON.parse(saved) : [];
  });
  
  const [selectedFileName, setSelectedFileName] = useState(() => {
    return localStorage.getItem("selectedFileName") || "";
  });
  
  const [cpuPopupVisible, setCpuPopupVisible] = useState(false);
  
  const [cpuVolume, setCpuVolume] = useState(() => {
    return localStorage.getItem("cpuVolume") || "";
  });
  
  const [cpuTarget, setCpuTarget] = useState(() => {
    return localStorage.getItem("cpuTarget") || "";
  });

  const [rfidInput, setRfidInput] = useState("");
  const [waitingForRfid, setWaitingForRfid] = useState(null);
  const [receivedBy, setReceivedBy] = useState(() => {
    const saved = localStorage.getItem("receivedBy");
    return saved ? JSON.parse(saved) : {};
  });

  const [rfidData, setRfidData] = useState(() => {
    const saved = localStorage.getItem("rfidData");
    return saved ? JSON.parse(saved) : [];
  });

  const [rfidUploadVisible, setRfidUploadVisible] = useState(false);
  const [rfidFileName, setRfidFileName] = useState(() => {
    return localStorage.getItem("rfidFileName") || "";
  });

  const navigate = useNavigate();

  // Save orders whenever they change
  useEffect(() => {
    console.log("üíæ Saving orders to localStorage:", orders.length, "orders");
    localStorage.setItem("orders", JSON.stringify(orders));
  }, [orders]);

  // Save filter settings
  useEffect(() => {
    localStorage.setItem("filterDate", filterDate);
  }, [filterDate]);

  useEffect(() => {
    localStorage.setItem("filterStatus", filterStatus);
  }, [filterStatus]);

  useEffect(() => {
    localStorage.setItem("filterCategory", filterCategory);
  }, [filterCategory]);

  // Save cost data
  useEffect(() => {
    console.log("üíæ Saving cost data to localStorage");
    localStorage.setItem("costData", JSON.stringify(costData));
  }, [costData]);

  // Save reorder products
  useEffect(() => {
    console.log("üíæ Saving reorder products to localStorage:", reorderProducts.length);
    localStorage.setItem("reorderProducts", JSON.stringify(reorderProducts));
  }, [reorderProducts]);

  // Save file name
  useEffect(() => {
    localStorage.setItem("selectedFileName", selectedFileName);
  }, [selectedFileName]);

  // Save CPU data
  useEffect(() => {
    if (cpuVolume !== "") {
      localStorage.setItem("cpuVolume", cpuVolume);
    }
  }, [cpuVolume]);

  useEffect(() => {
    if (cpuTarget !== "") {
      localStorage.setItem("cpuTarget", cpuTarget);
    }
  }, [cpuTarget]);

  // Save received by data
  useEffect(() => {
    console.log("üíæ Saving receivedBy to localStorage:", receivedBy);
    localStorage.setItem("receivedBy", JSON.stringify(receivedBy));
  }, [receivedBy]);

  // Save RFID data
  useEffect(() => {
    localStorage.setItem("rfidData", JSON.stringify(rfidData));
  }, [rfidData]);

  useEffect(() => {
    localStorage.setItem("rfidFileName", rfidFileName);
  }, [rfidFileName]);

  // RFID Reader Handler
  useEffect(() => {
    const handleKeyPress = (e) => {
      if (!waitingForRfid) return;

      // RFID readers typically send data followed by Enter key
      if (e.key === "Enter") {
        if (rfidInput.trim()) {
          console.log("üì° RFID Scanned:", rfidInput.trim());
          
          // Find matching ID and name from RFID data
          const rfidMatch = rfidData.find(
            (item) => item.cardNumber && item.cardNumber.toString().trim() === rfidInput.trim()
          );
          
          const displayText = rfidMatch && rfidMatch.idNumber && rfidMatch.name 
            ? `${rfidMatch.idNumber} - ${rfidMatch.name}`
            : rfidInput.trim();
          
          setReceivedBy(prev => ({
            ...prev,
            [waitingForRfid]: displayText
          }));
          setWaitingForRfid(null);
          setRfidInput("");
        }
      } else if (e.key.length === 1) {
        // Accumulate characters from RFID reader
        setRfidInput(prev => prev + e.key);
      }
    };

    if (waitingForRfid) {
      window.addEventListener("keypress", handleKeyPress);
      return () => window.removeEventListener("keypress", handleKeyPress);
    }
  }, [waitingForRfid, rfidInput, rfidData]);

  // Fetch from backend and merge with localStorage
  useEffect(() => {
    const fetchOrders = async () => {
      try {
        const res = await fetch("http://localhost:5000/api/orders");
        if (res.ok) {
          const backendOrders = await res.json();
          if (backendOrders && backendOrders.length > 0) {

            setOrders(prevOrders => {
              const existingOrdersMap = new Map();

              // Add previous orders (from localStorage)
              prevOrders.forEach(o => {
                if (o.id != null) existingOrdersMap.set(o.id.toString(), o);
              });

              // Add backend orders only if not already present
              backendOrders.forEach(o => {
                if (o.id != null && !existingOrdersMap.has(o.id.toString())) {
                  existingOrdersMap.set(o.id.toString(), {
                    ...o,
                    date: o.userDetails?.date || o.userDetails?.orderDate || o.date || new Date().toISOString().split('T')[0],
                    status: "Pending", // Set initial status for new backend orders
                    deliveredItems: [] // Initialize deliveredItems
                  });
                }
              });

              return Array.from(existingOrdersMap.values());
            });
          }
        }
      } catch (err) {
        console.log("‚ÑπÔ∏è Backend not available, using localStorage data only");
      }
    };

    const timer = setTimeout(fetchOrders, 300);
    return () => clearTimeout(timer);
  }, []);

  // Function to get category for a part number
  const getCategoryForPartNumber = (partNumber) => {
    const product = products.find(
      (p) => p.partNumber.trim().toLowerCase() === partNumber.trim().toLowerCase()
    );
    return product ? product.category : "N/A";
  };

  const openPopup = (order) => {
    const initialQuantities = {};
    (order.deliveredItems || []).forEach((item) => {
      // Use partNumber as unique key to avoid conflicts
      const uniqueKey = `${item.partNumber}_${item.id}`;
      initialQuantities[uniqueKey] = item.deliveredQty || 0;
    });
    setDeliveredQuantities(initialQuantities);
    setPopupOrder(order);
  };

  const updateStatus = (id, reject = false) => {
    console.log("üîÑ Updating order status:", id, reject ? "Reject" : "Approve");
    
    const updated = orders.map((o) => {
      if (o.id !== id) return o;
      if (reject) {
        console.log("‚ùå Rejecting order:", id);
        return { ...o, status: "Rejected" };
      }

      const allDelivered = o.cart.every((item) => {
        const uniqueKey = `${item.partNumber}_${item.id}`;
        const delivered = deliveredQuantities[uniqueKey] || 0;
        return delivered === item.quantity;
      });

      const status = allDelivered ? "Delivered" : "Partial";
      console.log("‚úÖ Setting order status to:", status);

      const deliveredItems = o.cart.map((item) => {
        const uniqueKey = `${item.partNumber}_${item.id}`;
        return {
          id: item.id,
          partNumber: item.partNumber,
          deliveredQty: deliveredQuantities[uniqueKey] || 0,
        };
      });

      return { ...o, status, deliveredItems };
    });

    console.log("üíæ Updated orders array:", updated.length);
    setOrders(updated);

    // Update stock when order is approved/delivered
    if (!reject) {
      try {
        const stockRaw = localStorage.getItem("savedStockData");
        let stockData = stockRaw ? JSON.parse(stockRaw) : [];

        const approvedOrder = updated.find((o) => o.id === id);
        if (approvedOrder && approvedOrder.deliveredItems) {
          console.log("üì¶ Updating stock for delivered items");
          
          approvedOrder.deliveredItems.forEach((delItem) => {
            if (!delItem.partNumber || delItem.deliveredQty <= 0) return;

            const index = stockData.findIndex(
              (s) => s.partNumber.toLowerCase() === delItem.partNumber.toLowerCase()
            );

            if (index !== -1) {
              const previousStock = stockData[index].currentStock;
              stockData[index].currentStock = Math.max(
                0,
                stockData[index].currentStock - delItem.deliveredQty
              );
              console.log(`üìâ ${delItem.partNumber}: ${previousStock} ‚Üí ${stockData[index].currentStock} (delivered: ${delItem.deliveredQty})`);
            } else {
              // Product not in stock, add with 0 stock (delivered more than available)
              const product = products.find(
                (p) => p.partNumber.toLowerCase() === delItem.partNumber.toLowerCase()
              );
              if (product) {
                stockData.push({
                  partNumber: product.partNumber,
                  productName: product.description,
                  currentStock: 0,
                });
                console.log(`‚ö†Ô∏è ${delItem.partNumber} not in stock, added with 0 quantity`);
              }
            }
          });

          localStorage.setItem("savedStockData", JSON.stringify(stockData));
          console.log("‚úÖ Stock updated successfully after delivery");
          
          // Trigger storage event for cross-tab communication
          window.dispatchEvent(new Event('stockUpdated'));
        }
      } catch (err) {
        console.error("‚ùå Error updating stock:", err);
      }
    }

    setPopupOrder(null);
    setDeliveredQuantities({});
  };

  const handleExcelUpload = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    console.log("üìÇ Uploading Excel file:", file.name);
    setSelectedFileName(file.name);

    const reader = new FileReader();
    reader.onload = (evt) => {
      try {
        const data = new Uint8Array(evt.target.result);
        const workbook = XLSX.read(data, { type: "array" });
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(sheet);

        console.log("üìä Excel data parsed, rows:", jsonData.length);
        
        // Store raw Excel data
        localStorage.setItem("uploadedExcel", JSON.stringify(jsonData));

        const productPartNumbers = products.map((p) => p.partNumber.trim().toLowerCase());

        // Process Excel data for cost analysis
        const matched = jsonData
          .map((row) => {
            const partNum = (row["Material"] || "").toString().trim();
            if (!partNum || !productPartNumbers.includes(partNum.toLowerCase())) return null;

            const unrestricted = Number(
              row["Unrestricted"] ||
                row["unrestricted"] ||
                row["Unrestricted Stock"] ||
                row["Unrestricted Qty"] ||
                0
            );
            const valueUnrestricted = Number(row["Value Unrestricted"] || 0);
            const costPerUnit =
              unrestricted > 0 ? valueUnrestricted / unrestricted : 0;

            return { partNumber: partNum, costPerUnit, unrestricted };
          })
          .filter((i) => i !== null);

        console.log("‚úÖ Matched products:", matched.length);
        setCostData(matched);

        // Process Excel data for stock display
        const stockData = jsonData
          .map((row) => {
            const partNum = (row["Material"] || "").toString().trim();
            if (!partNum) return null;

            // Check if product exists in products.js
            const normalizedPartNum = partNum.toLowerCase();
            if (!productPartNumbers.includes(normalizedPartNum)) {
              return null;
            }

            // Find the product to get description
            const product = products.find(
              (p) => p.partNumber.trim().toLowerCase() === normalizedPartNum
            );

            const productName = product 
              ? product.description 
              : (row["Material Description"] || row["Description"] || "Unknown Product");

            const currentStock = Number(
              row["Unrestricted"] || 
              row["unrestricted"] || 
              row["Unrestricted Stock"] ||
              0
            );

            return { 
              partNumber: partNum, 
              productName, 
              currentStock 
            };
          })
          .filter((item) => item !== null);

        console.log("‚úÖ Stock data processed:", stockData.length, "items");
        localStorage.setItem("savedStockData", JSON.stringify(stockData));
        
        // Trigger custom event for stock page to reload
        window.dispatchEvent(new Event('stockUpdated'));

        // Check reorder levels
        const reorderItems = [];
        matched.forEach((excelItem) => {
          const product = products.find(
            (p) => p.partNumber === excelItem.partNumber
          );
          
          if (product) {
            const reorderLevel = product.min || 0;
            const currentStock = excelItem.unrestricted;
            
            if (currentStock <= reorderLevel) {
              reorderItems.push({
                partNumber: product.partNumber,
                description: product.description,
                currentStock: currentStock,
                min: product.min || 0,
                max: product.max || 0,
                rol: product.rol || reorderLevel,
                roq: product.roq || (product.max - currentStock),
                location: product.location,
                category: product.category,
                glCode: product.glCode,
                costCenter: product.costCenter
              });
            }
          }
        });

        console.log("‚ö†Ô∏è Products below reorder level:", reorderItems.length);
        setReorderProducts(reorderItems);
        
        if (reorderItems.length > 0) {
          alert(`‚úÖ Excel uploaded successfully!\n‚ö†Ô∏è ${reorderItems.length} products are at or below reorder level!`);
        } else {
          alert(`‚úÖ Excel uploaded successfully!\n‚úÖ All products are above reorder level.`);
        }
        
      } catch (err) {
        console.error("Error reading Excel file:", err);
        alert("Error reading Excel file. Please check the file format.");
      }
    };
    reader.readAsArrayBuffer(file);
  };

  const handleRfidExcelUpload = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    console.log("üìÇ Uploading RFID Excel file:", file.name);
    setRfidFileName(file.name);

    const reader = new FileReader();
    reader.onload = (evt) => {
      try {
        const data = new Uint8Array(evt.target.result);
        const workbook = XLSX.read(data, { type: "array" });
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(sheet);

        console.log("üìä RFID Excel data parsed, rows:", jsonData.length);
        
        // Process RFID data - looking for Card Number, ID Number, and Name columns
        const processedData = jsonData.map((row) => {
          const cardNumber = row["Card Number"] || row["Card"] || row["RFID"] || row["RFID Number"] || "";
          const idNumber = row["ID Number"] || row["ID"] || row["Employee ID"] || row["EmpID"] || "";
          const name = row["Name"] || row["Employee Name"] || row["Employee"] || "";
          
          return {
            cardNumber: cardNumber.toString().trim(),
            idNumber: idNumber.toString().trim(),
            name: name.toString().trim()
          };
        }).filter(item => item.cardNumber && item.idNumber && item.name);

        console.log("‚úÖ RFID data processed:", processedData.length, "entries");
        setRfidData(processedData);
        
        alert(`‚úÖ RFID data uploaded successfully!\nüìä ${processedData.length} entries loaded.`);
        setRfidUploadVisible(false);
        
      } catch (err) {
        console.error("Error reading RFID Excel file:", err);
        alert("Error reading RFID Excel file. Please check the file format.\nExpected columns: 'Card Number', 'ID Number', and 'Name'");
      }
    };
    reader.readAsArrayBuffer(file);
  };

  const totalOrders = orders.length;
  const pending = orders.filter((o) => o.status === "Pending").length;
  const delivered = orders.filter((o) => o.status === "Delivered").length;
  const rejected = orders.filter((o) => o.status === "Rejected").length;
  const partial = orders.filter((o) => o.status === "Partial").length;

  const monthlyData = Object.values(
    orders.reduce((acc, o) => {
      // Get date from multiple possible locations
      const dateStr = o.date || o.userDetails?.date || o.userDetails?.orderDate;
      const d = dateStr ? new Date(dateStr) : null;
      const month = d && !isNaN(d)
        ? `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}`
        : "Unknown";
      if (!acc[month]) acc[month] = { month, amount: 0, count: 0 };
      acc[month].amount += o.totalAmount || 0;
      acc[month].count += 1;
      return acc;
    }, {})
  ).sort((a, b) => {
    if (a.month === "Unknown") return 1;
    if (b.month === "Unknown") return -1;
    return new Date(a.month) - new Date(b.month);
  });

  const zoneData = Object.values(
    orders.reduce((acc, o) => {
      const zone = o.userDetails?.zone || "Unknown";
      if (!acc[zone]) acc[zone] = { zone, count: 0 };
      acc[zone].count += 1;
      return acc;
    }, {})
  );

  const zoneMonthlyCost = Object.values(
    orders.reduce((acc, o) => {
      const dateStr = o.date || o.userDetails?.date || o.userDetails?.orderDate;
      const d = dateStr ? new Date(dateStr) : null;
      const month = d && !isNaN(d)
        ? `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}`
        : "Unknown";
      const zone = o.userDetails?.zone || "Unknown";
      const key = `${month}-${zone}`;
      if (!acc[key])
        acc[key] = {
          month,
          zone,
          totalAmount: 0,
          cpu: 0,
          cpuTarget: 0,
          "Fixed Cost - Material": 0,
          "Variable Cost - Labour": 0,
          "PPE's (Personal Protective Equipments)": 0,
        };

      if (o.cart && o.cart.length > 0 && costData.length > 0) {
        o.cart.forEach((item) => {
          const match = costData.find((c) => c.partNumber === item.partNumber);
          if (match) {
            const productInfo = products.find(
              (p) => p.partNumber === item.partNumber
            );
            if (productInfo) {
              if (productInfo.category.includes("Material")) {
                acc[key]["Fixed Cost - Material"] +=
                  item.quantity * match.costPerUnit;
              } else if (productInfo.category.includes("Labour")) {
                acc[key]["Variable Cost - Labour"] +=
                  item.quantity * match.costPerUnit;
              } else {
                acc[key]["PPE's (Personal Protective Equipments)"] +=
                  item.quantity * match.costPerUnit;
              }
              acc[key].totalAmount += item.quantity * match.costPerUnit;
            }
          }
        });
      }

      if (cpuVolume) acc[key].cpu = cpuVolume > 0 ? acc[key].totalAmount / cpuVolume : 0;
      if (cpuTarget) acc[key].cpuTarget = Number(cpuTarget);

      return acc;
    }, {})
  ).sort((a, b) => a.zone.localeCompare(b.zone));

  // Get unique categories from all orders
  const allCategories = [...new Set(
    orders.flatMap(o => 
      o.cart.map(item => getCategoryForPartNumber(item.partNumber))
    )
  )].filter(cat => cat !== "N/A").sort();

  const filteredOrders = orders.filter((o) => {
    const orderDate = o.date || o.userDetails?.date || o.userDetails?.orderDate;
    const dateMatch = filterDate ? orderDate === filterDate : true;
    const statusMatch = filterStatus === "All" ? true : o.status === filterStatus;
    
    // Category filter - check if any item in the cart matches the selected category
    const categoryMatch = filterCategory === "All" ? true : 
      o.cart.some(item => getCategoryForPartNumber(item.partNumber) === filterCategory);
    
    return dateMatch && statusMatch && categoryMatch;
  });

  const downloadFilteredExcel = () => {
    if (!filteredOrders.length) {
      alert("No data to export!");
      return;
    }

    const exportData = filteredOrders.flatMap((o) =>
      o.cart.map((i) => {
        const productInfo = products.find((p) => p.partNumber === i.partNumber);
        
        // Find issued quantity from deliveredItems
        const uniqueKey = `${i.partNumber}_${i.id}`;
        let issuedQty = 0;
        
        if (o.deliveredItems && o.deliveredItems.length > 0) {
          const deliveredItem = o.deliveredItems.find(
            (di) => di.partNumber === i.partNumber && di.id === i.id
          );
          if (deliveredItem) {
            issuedQty = deliveredItem.deliveredQty || 0;
          }
        }
        
        return {
          Employee: o.userDetails?.name || "N/A",
          EmpID: o.userDetails?.empId || "N/A",
          Department: o.userDetails?.dept || "N/A",
          Zone: o.userDetails?.zone || "N/A",
          Date: o.date || o.userDetails?.date || o.userDetails?.orderDate || "N/A",
          Category: getCategoryForPartNumber(i.partNumber),
          PartNumber: i.partNumber,
          Description: i.description,
          Quantity: i.quantity,
          IssuedQuantity: issuedQty,
          Location: productInfo ? productInfo.location : "N/A",
          GLCode: productInfo ? productInfo.glCode : "N/A",
          CostCenter: productInfo ? productInfo.costCenter : "N/A",
          Status: o.status,
          ReceivedBy: receivedBy[o.id] || "N/A",
        };
      })
    );

    const worksheet = XLSX.utils.json_to_sheet(exportData);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, "Filtered Orders");
    XLSX.writeFile(workbook, "FilteredOrders.xlsx");
  };

  return (
    <div className="dashboard">
      <div className="renault-logo-top">
        <img src="/renault-group-logo.png" alt="Renault" />
      </div>
      <div className="renault-logo-bg"></div>
      
      <h1>üìä Manager Dashboard</h1>

      {/* Summary cards */}
      <div className="summary-cards">
        <div className="summary-card total">Total Orders: {totalOrders}</div>
        <div className="summary-card pending">Pending: {pending}</div>
        <div className="summary-card partial">Partial: {partial}</div>
        <div className="summary-card approved">Delivered: {delivered}</div>
        <div className="summary-card rejected">Rejected: {rejected}</div>
      </div>

      {/* Buttons row */}
<div className="button-row">
  <button className="action-btn filter" onClick={() => setFilterVisible(true)}>
    üîç Filter
  </button>
  <button className="action-btn upload" onClick={() => setUploadVisible(true)}>
    üìÇ Upload Excel
  </button>
  <button className="action-btn reorder" onClick={() => setReorderVisible(true)}>
    üì¶ Reorder Level ({reorderProducts.length})
  </button>
  <button className="action-btn cpu" onClick={() => setCpuPopupVisible(true)}>
    ‚öô PRODUCTION VOLUME AND TARGET DATA
  </button>
  <button
    className="action-btn stock"
    onClick={() => navigate("/stock-management")}
  >
    üìä Stock Management
  </button>
  <button 
    className="action-btn" 
    onClick={() => setRfidUploadVisible(true)}
    style={{ backgroundColor: "#6f42c1" }}
  >
    üìá Upload RFID Data
  </button>
  <button 
    className="action-btn" 
    onClick={() => {
      if (window.confirm("‚ö†Ô∏è Are you sure you want to clear all data? This will delete:\n\n‚Ä¢ All Orders\n‚Ä¢ RFID Data\n‚Ä¢ Received By Information\n‚Ä¢ Filter Settings\n‚Ä¢ Cost Data\n‚Ä¢ Reorder Products\n‚Ä¢ CPU Data\n\nThis action cannot be undone!")) {
        // Clear all localStorage data
        localStorage.removeItem("orders");
        localStorage.removeItem("receivedBy");
        localStorage.removeItem("rfidData");
        localStorage.removeItem("rfidFileName");
        localStorage.removeItem("filterDate");
        localStorage.removeItem("filterStatus");
        localStorage.removeItem("filterCategory");
        localStorage.removeItem("costData");
        localStorage.removeItem("reorderProducts");
        localStorage.removeItem("selectedFileName");
        localStorage.removeItem("cpuVolume");
        localStorage.removeItem("cpuTarget");
        localStorage.removeItem("uploadedExcel");
        
        // Reset state
        setOrders([]);
        setReceivedBy({});
        setRfidData([]);
        setRfidFileName("");
        setFilterDate("");
        setFilterStatus("All");
        setFilterCategory("All");
        setCostData([]);
        setReorderProducts([]);
        setSelectedFileName("");
        setCpuVolume("");
        setCpuTarget("");
        
        alert("‚úÖ All data has been cleared successfully!");
        
        // Reload the page to fetch fresh orders from backend
        window.location.reload();
      }
    }}
    style={{ backgroundColor: "#dc3545" }}
  >
    üóëÔ∏è Clear All Data
  </button>
</div>

      {/* RFID Upload popup */}
      {rfidUploadVisible && (
        <div className="popup-overlay" onClick={() => setRfidUploadVisible(false)}>
          <div className="popup" onClick={(e) => e.stopPropagation()}>
            <h3>üìá Upload RFID Data</h3>
            <p style={{ fontSize: "14px", color: "#666", marginBottom: "10px" }}>
              Excel should contain columns: <strong>Card Number, ID Number, Name</strong>
            </p>
            <input type="file" accept=".xlsx,.xls" onChange={handleRfidExcelUpload} />
            {rfidFileName && <p>üìÑ Selected File: <strong>{rfidFileName}</strong></p>}
            {rfidData.length > 0 && (
              <p style={{ color: "#28a745", fontWeight: "bold" }}>
                ‚úÖ {rfidData.length} RFID entries loaded
              </p>
            )}
            <div className="filter-actions">
              <button onClick={() => setRfidUploadVisible(false)}>Close</button>
            </div>
          </div>
        </div>
      )}

      {/* CPU popup */}
      {cpuPopupVisible && (
        <div className="popup-overlay" onClick={() => setCpuPopupVisible(false)}>
          <div className="popup" onClick={(e) => e.stopPropagation()}>
            <h3>‚öô CPU Volume & Target</h3>
            <label>Volume:</label>
            <input
              type="number"
              value={cpuVolume}
              onChange={(e) => setCpuVolume(e.target.value)}
            />
            <label>Target:</label>
            <input
              type="number"
              value={cpuTarget}
              onChange={(e) => setCpuTarget(e.target.value)}
            />
            <div className="filter-actions">
              <button onClick={() => setCpuPopupVisible(false)}>Apply</button>
              <button onClick={() => setCpuPopupVisible(false)}>Cancel</button>
            </div>
          </div>
        </div>
      )}

      {/* Upload popup */}
      {uploadVisible && (
        <div className="popup-overlay" onClick={() => setUploadVisible(false)}>
          <div className="popup" onClick={(e) => e.stopPropagation()}>
            <h3>üìÇ Upload Excel File</h3>
            <p style={{ fontSize: "14px", color: "#666", marginBottom: "10px" }}>
              Excel should contain columns: <strong>Material, Material Description, Unrestricted</strong>
            </p>
            <input type="file" accept=".xlsx,.xls" onChange={handleExcelUpload} />
            {selectedFileName && <p>üìÑ Selected File: <strong>{selectedFileName}</strong></p>}
            <div className="filter-actions">
              <button onClick={() => setUploadVisible(false)}>Close</button>
            </div>
          </div>
        </div>
      )}

      {/* Filter popup */}
      {filterVisible && (
        <div className="filter-overlay" onClick={() => setFilterVisible(false)}>
          <div className="filter-popup" onClick={(e) => e.stopPropagation()}>
            <h3>Filter Orders</h3>
            <label>Date:</label>
            <input type="date" value={filterDate} onChange={(e) => setFilterDate(e.target.value)} />
            <label>Status:</label>
            <select value={filterStatus} onChange={(e) => setFilterStatus(e.target.value)}>
              <option>All</option>
              <option>Pending</option>
              <option>Partial</option>
              <option>Delivered</option>
              <option>Rejected</option>
            </select>
            <label>Category:</label>
            <select value={filterCategory} onChange={(e) => setFilterCategory(e.target.value)}>
              <option>All</option>
              {allCategories.map((cat, idx) => (
                <option key={idx} value={cat}>{cat}</option>
              ))}
            </select>

            <div style={{ display: "flex", gap: "10px", marginTop: "10px" }}>
              <button
                onClick={() => setFilterVisible(false)}
                style={{
                  flex: 1,
                  padding: "10px",
                  backgroundColor: "#28a745",
                  color: "#fff",
                  border: "none",
                  borderRadius: "5px",
                  cursor: "pointer",
                  fontWeight: "bold",
                }}
              >
                Apply
              </button>
              <button
                onClick={() => { setFilterDate(""); setFilterStatus("All"); setFilterCategory("All"); setFilterVisible(false); }}
                style={{
                  flex: 1,
                  padding: "10px",
                  backgroundColor: "#dc3545",
                  color: "#fff",
                  border: "none",
                  borderRadius: "5px",
                  cursor: "pointer",
                  fontWeight: "bold",
                }}
              >
                Reset
              </button>
            </div>

            <div style={{ marginTop: "10px" }}>
              <button
                onClick={downloadFilteredExcel}
                style={{
                  width: "100%",
                  backgroundColor: "#17a2b8",
                  color: "#fff",
                  padding: "10px",
                  border: "none",
                  borderRadius: "5px",
                  cursor: "pointer",
                }}
              >
                ‚¨á Download Excel
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Reorder Level popup */}
      {reorderVisible && (
        <div className="popup-overlay">
          <div className="popup">
            <h3>üì¶ Products Below Reorder Level</h3>
            {reorderProducts.length === 0 ? (
              <p>‚úÖ All products are above reorder level.</p>
            ) : (
              <div style={{ maxHeight: "400px", overflowY: "auto" }}>
                {reorderProducts.map((p, idx) => (
                  <div key={idx} className="reorder-item" style={{ 
                    padding: "10px", 
                    margin: "5px 0", 
                    backgroundColor: "#f8d7da",
                    borderRadius: "5px",
                    border: "1px solid #f5c6cb"
                  }}>
                    <strong>{p.partNumber}</strong> - {p.description}
                    <br />
                    üìä Current Stock: <span style={{ color: "red", fontWeight: "bold" }}>{p.currentStock}</span>  
                    <br />
                    üîÑ ROL: <span style={{ color: "orange", fontWeight: "bold" }}>{p.rol}</span> | 
                    üì¶ ROQ: <span style={{ color: "green", fontWeight: "bold" }}>{p.roq}</span>
                  </div>
                ))}
              </div>
            )}
            <button onClick={() => setReorderVisible(false)} style={{ marginTop: "15px" }}>Close</button>
          </div>
        </div>
      )}

      {/* Graphs */}
      <div className="graph-section" style={{ display: "flex", gap: "20px", flexWrap: "wrap" }}>
        <div style={{ flex: 1, minWidth: 300 }}>
          <h3>Monthly Orders Count</h3>
          <ResponsiveContainer width="100%" height={250}>
            <BarChart data={monthlyData}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="month" />
              <YAxis />
              <Tooltip />
              <Legend />
              <Bar dataKey="count" fill="#8884d8" />
            </BarChart>
          </ResponsiveContainer>
        </div>

        <div style={{ flex: 1, minWidth: 300 }}>
          <h3>Orders by Zone</h3>
          <ResponsiveContainer width="100%" height={250}>
            <BarChart data={zoneData}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="zone" />
              <YAxis />
              <Tooltip />
              <Legend />
              <Bar dataKey="count" fill="#17a2b8" />
            </BarChart>
          </ResponsiveContainer>
        </div>

        <div style={{ flex: 1, minWidth: 300, marginTop: 0 }}>
          <h3>Zone-wise Monthly Cost</h3>
          <ResponsiveContainer width="100%" height={250}>
            <BarChart data={zoneMonthlyCost}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="zone" />
              <YAxis />
              <Tooltip />
              <Legend />
              <Bar dataKey="Fixed Cost - Material" stackId="a" fill="#8884d8" />
              <Bar dataKey="Variable Cost - Labour" stackId="a" fill="#82ca9d" />
              <Bar
                dataKey="PPE's (Personal Protective Equipments)"
                stackId="a"
                fill="#ffc658"
              />
              {cpuVolume && <Bar dataKey="cpu" fill="#ff4d4f" />}
              {cpuTarget && (
                <Line
                  type="monotone"
                  dataKey="cpuTarget"
                  stroke="#000"
                  strokeDasharray="5 5"
                  dot={false}
                />
              )}
            </BarChart>
          </ResponsiveContainer>
        </div>
      </div>

      {/* Orders Table */}
      <div className="table-container">
        <table>
          <thead>
            <tr>
              <th>Employee</th>
              <th>Emp ID</th>
              <th>Dept</th>
              <th>Zone</th>
              <th>Date</th>
              <th>Category</th>
              <th>Items</th>
              <th>Location</th>
              <th>Status</th>
              <th>Received By</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody>
            {filteredOrders.map((o) => {
              const displayDate = o.date || o.userDetails?.date || o.userDetails?.orderDate || "N/A";
              
              // Get categories for this order
              const orderCategories = [...new Set(o.cart.map(item => getCategoryForPartNumber(item.partNumber)))];
              
              return (
                <tr key={o.id}>
                  <td>{o.userDetails?.name || "N/A"}</td>
                  <td>{o.userDetails?.empId || "N/A"}</td>
                  <td>{o.userDetails?.dept || "N/A"}</td>
                  <td>{o.userDetails?.zone || "N/A"}</td>
                  <td>{displayDate}</td>
                  <td>
                    {orderCategories.map((cat, idx) => (
                      <div key={idx}>{cat}</div>
                    ))}
                  </td>
                  <td>
                    {o.cart.map((i) => (
                      <div key={i.id}>
                        {i.partNumber} - {i.description} (x{i.quantity})
                      </div>
                    ))}
                  </td>
                  <td>
                    {o.cart.map((i) => {
                      const productInfo = products.find((p) => p.partNumber === i.partNumber);
                      return (
                        <div key={i.id}>
                          {i.partNumber} - {productInfo ? productInfo.location : "N/A"}
                        </div>
                      );
                    })}
                  </td>
                  <td>{o.status}</td>
                  <td>
                    {receivedBy[o.id] ? (
                      <span style={{ color: "#28a745", fontWeight: "bold" }}>
                         {receivedBy[o.id]}
                      </span>
                    ) : (
                      <button
                        className="rfid-btn"
                        onClick={() => {
                          if (o.status === "Delivered") {
                            setWaitingForRfid(o.id);
                            setRfidInput("");
                          }
                        }}
                        disabled={o.status !== "Delivered"}
                        style={{
                          backgroundColor: 
                            o.status !== "Delivered" ? "#6c757d" : 
                            waitingForRfid === o.id ? "#ffc107" : "#007bff",
                          color: "#fff",
                          border: "none",
                          padding: "5px 10px",
                          borderRadius: "4px",
                          cursor: o.status !== "Delivered" ? "not-allowed" : "pointer",
                          fontWeight: "bold",
                          opacity: o.status !== "Delivered" ? 0.6 : 1,
                        }}
                      >
                        {waitingForRfid === o.id ? "‚è≥ Waiting..." : "üì° Scan ID"}
                      </button>
                    )}
                  </td>
                  <td>
                    <button
                      className={`approve-btn ${
                        o.status === "Partial"
                          ? "partial"
                          : o.status === "Delivered"
                          ? "delivered"
                          : ""
                      }`}
                      onClick={() => openPopup(o)}
                      disabled={o.status === "Rejected"}
                    >
                      {o.status === "Partial"
                        ? "Partial"
                        : o.status === "Delivered"
                        ? "Delivered"
                        : "Approve"}
                    </button>
                    <button
                      className="reject-btn"
                      onClick={() => updateStatus(o.id, true)}
                      disabled={o.status === "Rejected" || o.status === "Delivered" || o.status === "Partial"}
                    >
                      ‚ùå Reject
                    </button>
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>

      {/* Delivery Popup */}
      {popupOrder && (
        <div className="popup-overlay">
          <div className="popup">
            <h3>Select Delivered Quantities</h3>
            {popupOrder.cart.map((item, index) => {
              const uniqueKey = `${item.partNumber}_${item.id}`;
              return (
                <div key={uniqueKey} className="checkbox-item">
                  <label>
                    {item.partNumber} - {item.description} (Requested: {item.quantity})
                  </label>

                  {item.quantity === 1 ? (
                    <input
                      type="checkbox"
                      checked={deliveredQuantities[uniqueKey] === 1}
                      onChange={(e) =>
                        setDeliveredQuantities((prev) => ({
                          ...prev,
                          [uniqueKey]: e.target.checked ? 1 : 0,
                        }))
                      }
                      style={{ marginLeft: "10px" }}
                    />
                  ) : (
                    <input
                      type="number"
                      min="0"
                      max={item.quantity}
                      value={deliveredQuantities[uniqueKey] || 0}
                      onChange={(e) =>
                        setDeliveredQuantities((prev) => ({
                          ...prev,
                          [uniqueKey]: Number(e.target.value),
                        }))
                      }
                      style={{ width: "60px", marginLeft: "10px" }}
                    />
                  )}
                </div>
              );
            })}
            <button onClick={() => updateStatus(popupOrder.id)}>Confirm Delivery</button>
            <button onClick={() => setPopupOrder(null)}>Cancel</button>
          </div>
        </div>
      )}
    </div>
  );
}